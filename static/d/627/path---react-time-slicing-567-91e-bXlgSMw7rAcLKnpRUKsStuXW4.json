{"data":{"site":{"siteMetadata":{"title":"Growing in the web","author":"Yichaoz"}},"markdownRemark":{"id":"eed85c1d-b218-5768-985a-dbfb66646585","excerpt":"Normally React wants to keep the UI consistent with what you told it to render.\nSo if you renderthen it will have to call render methods and…","html":"<p>Normally React wants to keep the UI consistent with what you told it to render.\nSo if you render</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Slideshow() {\n  return (\n    &lt;div&gt;\n      &lt;Expensive1 /&gt;\n      &lt;Expensive2 /&gt;\n      &lt;Expensive3 /&gt;\n    &lt;/div&gt;\n  );\n}</code></pre></div>\n<p>then it will have to call render methods and create DOM nodes for the whole trees of Expensive1, Expensive2, and Expensive3, when Slideshow is being mounted.</p>\n<p>However, maybe you’re only showing Expensive1 on the first render, and Expensive2 and Expensive3 are not immediately visible. Like if this is really a side show.</p>\n<p>Today, it’s idiomatic to render just the current node, e.g.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Slideshow(props) {\n  return (\n    &lt;div&gt;\n      {props.current === 0 &amp;&amp; &lt;Expensive1 /&gt;}\n      {props.current === 1 &amp;&amp; &lt;Expensive2 /&gt;}\n      {props.current === 2 &amp;&amp; &lt;Expensive3 /&gt;}\n    &lt;/div&gt;\n  );\n}</code></pre></div>\n<p>The upside of this is that now your first render of <code class=\"language-text\">&lt;Slideshow current={0} /&gt;</code> only includes Expensive1. However, the downside is that the moment you switch to <code class=\"language-text\">&lt;Slideshow current={1} /&gt;</code>, you will experience jank from creating and rendering the whole Expensive2 tree.</p>\n<p>Ideally what we want to do is to tell React that when we render <code class=\"language-text\">&lt;Slideshow current={0} /&gt;</code>, we want to show Expensive1, but we want to start preparing Expensive2 when the browser is idle. This way it won’t block the initial render or cause jank, but by the time you click “next” Expensive2 might just already be complete, and in this case it’ll just replace the DOM node.</p>\n<p>This is exactly what time slicing which I partially demoed in my talk will allow. Your code might look something like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Slideshow(props) {\n  return (\n    &lt;div&gt;\n      &lt;div hidden={props.current !== 0}&gt;\n        &lt;Expensive1 /&gt;\n      &lt;/div&gt;\n      &lt;div hidden={props.current !== 1}&gt;\n        &lt;Expensive2 /&gt;\n      &lt;/div&gt;\n      &lt;div hidden={props.current !== 2}&gt;\n        &lt;Expensive3 /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}</code></pre></div>\n<p>Note that hidden is a real HTML attribute. (It acts similar to display: none.) But it could also serve as a hint to React that the tree inside it doesn’t actually need to be committed immediately — because it’s not visible anyway. Also note: this is not a final API, I’m just explaining what it lets you do.</p>\n<p>So when you render <code class=\"language-text\">&lt;Slideshow current={0} /&gt;</code>, React mounts</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;div&gt;\n  &lt;div hidden={false}&gt;\n    &lt;Expensive1 /&gt;\n  &lt;/div&gt;\n  &lt;div hidden={true}&gt;\n    &lt;!-- not ready yet --&gt;\n  &lt;/div&gt;\n  &lt;div hidden={true}&gt;\n    &lt;!-- not ready yet --&gt;\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre></div>\n<p>and whenever the browser is idle (e.g. when you look at the first slideshow item), it will start working on Expensive2 in small chunks. When it’s ready, it will just append it to the hidden div — which won’t be observable to the user because it’s hidden.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;div&gt;\n  &lt;div hidden={false}&gt;\n    &lt;Expensive1 /&gt;\n  &lt;/div&gt;\n  &lt;div hidden={true}&gt;\n    &lt;!-- not visible, but prepared during idle periods and now ready! --&gt;\n    &lt;Expensive2 /&gt;\n  &lt;/div&gt;\n  &lt;div hidden={true}&gt;\n    &lt;!-- not ready yet, but React will start working on it next --&gt;\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre></div>\n<p>Now if you switch to <code class=\"language-text\">&lt;Slideshow current={1} /&gt;</code>, React doesn’t need to do any extra rendering because it has already “prepared” Expensive2 ahead of time.</p>\n<p>And if you switch too fast, and React hasn’t been able to fully prepare Expensive2 yet, it will just pick it up where it left off but set a much more aggressive deadline since we want to see results within ~150ms.</p>\n<p>I hope this explains it a bit! The crucial part here is time slicing. This optimization wouldn’t make sense if pre-rendering Expensive2 or Expensive3 blocked the thread since in this case it wouldn’t be worth slowing down the interactions while Expensive1 is visible. But thanks to React’s architecture, we can actually start pre-rendering Expensive2 and Expensive3 in small chunks without blocking the thread, and that’s what will enable this optimization.</p>\n<p>Source: <a href=\"https://github.com/oliviertassinari/react-swipeable-views/issues/453#issuecomment-417939459\">github</a></p>","frontmatter":{"title":"React 16 time slicing trick","date":"September 09, 2018"}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"There sometimes we have a div like these :But we would like independently of the screen size, they should always be square, which means has…","fields":{"slug":"/2019-08-21-css-scale-while-keeping-aspect-ratio/"},"frontmatter":{"date":"22 August, 2019","title":"CSS scale content while keeping aspect ratio","tags":["css"]}}},{"node":{"excerpt":"Normally React wants to keep the UI consistent with what you told it to render.\nSo if you renderthen it will have to call render methods and…","fields":{"slug":"/react-time-slicing/"},"frontmatter":{"date":"09 September, 2018","title":"React 16 time slicing trick","tags":["reactjs","javascript"]}}},{"node":{"excerpt":"Given these classes:Which color would these divs be?Now see the answer ;)https://codepen.io/kossel/pen/PdEdLP","fields":{"slug":"/css-test/"},"frontmatter":{"date":"09 September, 2018","title":"How good are you with css","tags":["css"]}}},{"node":{"excerpt":"Hello world !","fields":{"slug":"/me/"},"frontmatter":{"date":"26 August, 2018","title":"Me","tags":["reactjs","javascript"]}}},{"node":{"excerpt":"tl;drAccording to React documentationIt just returns You can also see it in the source code (react 16.2.0)When it’s  it does shallow…","fields":{"slug":"/default-implementation-of-shouldcomponentunpdate/"},"frontmatter":{"date":"13 December, 2017","title":"Default implementation of shouldComponentUnpdate","tags":["reactjs","javascript"]}}},{"node":{"excerpt":"In react world, many time we call  and , I do that and saw in many places, however I’ve never asked myself what does it actually do…eg.So…","fields":{"slug":"/why-call-super-or-super-props/"},"frontmatter":{"date":"13 December, 2017","title":"Why call super or super(props)","tags":["reactjs","javascript"]}}},{"node":{"excerpt":"In React 16.2, improved support for Fragments has been added. More information can be found on React’s blog post here.We are all familiar…","fields":{"slug":"/react-16-fragment-vs-container-divs/"},"frontmatter":{"date":"13 December, 2017","title":"React 16 fragment vs container divs","tags":["reactjs","javascript"]}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/react-time-slicing/","previous":{"fields":{"slug":"/css-test/"},"frontmatter":{"title":"How good are you with css","tags":["css"]}},"next":{"fields":{"slug":"/2019-08-21-css-scale-while-keeping-aspect-ratio/"},"frontmatter":{"title":"CSS scale content while keeping aspect ratio","tags":["css"]}}}}